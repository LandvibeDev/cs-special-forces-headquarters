# CH.04 프로그램의 구조와 실행

## 1. 프로그램의 구조와 인터럽트

- 우리가 사용하는 컴퓨터 프로그램의 내부 구조는 "함수들"로 구성
- 프로그램이 CPU에서 명령을 수행하려면 해당 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야 한다.
- 프로그램의 주소 영역은 크게 코드(code), 데이터(data), 스택(stack) 영역으로 구분된다.
    - 1) 코드 영역 : 우리가 작성한 프 로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 부분
    - 2) 데이터 영역 : 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분
    - 3) 스택 영역 : 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데에 사용되는 공간
- 우리가 작성한 프로그램은 처음 CPU가 메인함수의 코드를 수행하다가 메인 함수가 다른 함수를 호출하면, 새로운 함수 위치로 점프해 함수 수행이 완료된 후에는 원래 호출했던 함수 위치로 돌아오게 된다.
    - 이때 돌아와야 하는 지점(복귀 주소)을 **스택**에 저장한다.
    - 즉, 함수가 호출되면 다음에 실행할 명령의 메모리 위치가 바뀌게 된다.

- **인터럽트**의 동작 원리도 함수의 호출과 비슷하다.
    - A라는 프로그램이 CPU를 할당받고 명령을 수행하고 있는데 인터럽트가 발생하면 A는 현재 수행중인 명령의 위치를 저장해놓는다.
    - 그 후 운영체제 내부 코드인 **인터럽트 처리루틴**으로 넘어가서 인터럽트 처리를 하고 다시 돌아와 A의 이전 작업 지점부터 수행을 계속 이어가게 된다.
- 프로그램의 함수호출에 필요한 복귀 주소는 각 프로그램의 주소 공간 중 스택 영역에 보관하는 반면 인터럽트 때문에 CPU를 빼앗긴 위치는 운영체제가 관리하는 **프로세스 제어블록**에 저장된다
- **프로세스 제어블록** ➡  ****프로세스가 발생한 시점에서 그 프로그램의 어느 부분까지 수행했는지를 저장하며, 인터럽트 처리 후 프로세스 제어블록에 저장된 주소를 복원시켜 원래 수행하던 일을 재개하게 된다.

## 2. 컴퓨터 시스템의 작동 개요

- CPU는 매 시점 메모리의 특정 주소에 존재하는 명령을 하나씩 읽어와 그대로 실행한다.
- 이때 CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 **프로그램 카운터(PC)** 라고 부른다.
- 즉 CPU는 매번 PC가 가리키는 메모리 위치의 명령을 처리하게 된다.
    - ex) 조건문, 반복문, 함수호출 등에 의한 주소 이동이 없는 이상 프로그램 카운터는 항상 바로 다음 명령을 가리키게 되어 코드의 순차적인 수행이 이루어진다.
- 컴퓨터 시스템의 동작이 CPU에 의해서만 이루어지는 것은 아니다
    - 디스크에서 파일 읽어오기, 키보드로부터 입력 받거나 처리 결과를 화면에 출력하기 등
- 컴퓨터 시스템을 구성하는 하드웨어 : CPU, 메모리
- 입출력 장치별로 존재하는 작은 CPU와 메모리를 각각 **입출력 컨트롤러**와 **로컬버퍼**라고 부른다.

- **메모리** ➡  사용자 프로그램들과 운영체제가 같이 올라가 수행된다.
    - CPU는 프로그램 카운터가 가리키는 메모리 위치의 프로그램을 수행한다.
        - ex) PC가 메모리 주소 중 운영체제가 존재하는 부분을 가리키고 있다면 **커널모드**에서 수행중이라고 이야기한다.
    - PC가 사용자 프로그램이 존재하는 메모리 위치를 가리키고 있다면 **사용자모드(user mode)**에서 CPU가 수행되고 있다고 이야기한다.

    ![0](Untitled.png)

- CPU가 수행하는 명령에는 **일반명령**과 **특권명령**이 있다.
1. 일반명령 : 메모리에서 자료를 읽어와 CPU에서 계산하고 결과를 메모리에 쓰는 일련의 명령들로, 모든 프로그램이 수행할 수 있는 명령이다.
2. 특권명령 : 보안이 필요한 명령으로 입출력 장치, 타이머 등 각종 장치에 접근하는 명령

- 컴퓨터 시스템에서는 이러한 **특권명령을 항상 운영체제만**이 수행할 수 있도록 제한하고 있다.
- 컴퓨터 시스템은 이 두 명령의 실행가능성을 체크하기 위해 CPU 내에 **모드 비트**를 둔다.

- 사용자 프로그램이 실행되다 보면 특권명령의 수행이 필요한 경우가 있다.
    - ex) 디스크의 파일에 접근하거나, 수행 결과를 화면에 출력하는 등의 작업
    - 이 경우에 사용자 프로그램은 스스로 특권명령을 수행할 수 없으므로 운영체제에게 특권 명령의 대행을 요청한다 (=시스템 콜)
    - 사용자 프로그램이 시스템 콜을 하게되면 운영체제는 사용자 프로그램의 코드가 아닌 커널 영역에 정의된 시스템 콜 처리 코드를 수행하게 된다.
    - ex) 디스크에서 자료를 읽어오는 시스템 콜
        1. CPU가 디스크 컨트롤러에게 데이터를 읽어오라는 명령을 내림
        2. 디스크 컨트롤러는 디스크로부터 데이터를 읽어와서 자신의 로컬버퍼에 저장
        3. 디스크 컨트롤러가 CPU에 인터럽트를 발생시켜 입출력 작업이 완료되었음을 통지한다.

    - CPU는 PC가 가리키는 메모리 위치의 명령만 계속 수행하기 때문에 주변장치의 상태를 지속적으로 파악하지 못함 → 주변장치는 인터럽트를 사용해 CPU에게 서비스를 요청함
    - 인터럽트를 발생시키기 위해 주변장치는 인터럽트 라인을 세팅하고, CPU는 매번 명령을 수행한 직후 인터럽트 라인을 체크한다.
    - 인터럽트의 종류는 다양하기 때문에 각각의 인터럽트 발생 원인마다 라인을 다르게 해서 구분하게 된다.

    ➡ 인터럽트가 발생하면 CPU는 해당 인터럽트를 처리하기 위한 루틴으로 넘어가서 커널 내의 인터럽트 처리 코드를 수행한다.

 

## 3. 프로그램의 실행

'프로그램이 실행되고 있다'의 컴퓨터 시스템 차원의 중요한 의미 2가지

1. 디스크에 존재하던 실행파일이 메모리에 적재된다는 의미
2. 프로그램이 CPU를 할당받고 명령을 수행하고 있는 상태라는 의미

- 일반적인 컴퓨터 시스템의 경우 CPU는 1개 ➡  매 시점 CPU에서 명령을 수행하는 프로그램 1개
- BUT, 여러 프로그램이 짧은 시간 단위로 CPU를 나눠 쓰고, 이들 프로그램이 메모리에 동시에 적재되어 있을 수도 있으므로 '여러 프로그램이 동시에 실행된다'는 말을 사용하는 것이다.

![1](Untitled%201.png)

- 실행파일이 메모리에 적재될 때, 전체가 아닌 일부만 메모리에 올라가고 나머지는 디스크의 특정 영역(스왑 영역)에 내려가 있는 것이 일반적이다.

    ➡  多 프로그램이 함께 사용하는 메모리 공간을 효율적으로 사용하기 위함

- 프로세스의 주소 공간을 우리는 가상메모리(virtual memory) 또는 논리적 메모리(logical memory)라고 부른다.

![2](Untitled%202.png)

- 운영체제도 하나의 프로그램 → 커널 역시 코드, 데이터, 스택의 주소 공간을 가지고 있다.
    - 운영체제의 기능 : 하드웨어 자원을 효율적으로 관리, 응용 프로그램 및 사용자에게 편리한 서비스를 제공
    - 1) 커널의 코드
        - CPU, 메모리 등 자원을 관리하기 위한 부분과 사용자에게 편리한 인터페이스를 제공하기 위한 부분
        - 시스템 콜 및 인터럽트를 처리하기 위한 부분
    - 2) 데이터 영역
        - 각종 자원을 관리하기 위한 자료구조가 저장됨
        - CPU나 메모리와 같은 하드웨어 자원을 관리하기 위한 자료구조 뿐 아니라 현재 수행중인 프로그램을 관리하기 위한 자료구조도 포함
        - 각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지하기 위한 자료구조인 **PCB**를 두고 있다.
        - PCB(프로세스 제어 블록, Process Control Block)란?

            : 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는, 운영체제 커널의 자료구조

            : 운영체제가 프로세스 스케줄링을 위해 프로세스에 관한 모든 정보를 가지고 있는 데이터베이스

    - 3) 스택 영역
        - 함수호출시의 복귀 주소를 저장하기 위한 용도
        - 일반 사용자 프로그램의 스택과 달리 현재 수행 중인 프로세스마다 별도의 스택을 두어 관리한다.

            ➡  프로세스가 함수를 호출할 때 자기 주소 영역 내부에 정의된 함수를 호출하면 자신의 스택에 복귀 주소를 저장하지만, 프로세스가 특권명령을 수행하려고 커널에 정의된 시스템 콜을 호출하고 시스템 콜 내부에서 다른 함수 호출하는 경우 그 복귀 주소는 커널 내의 주소가 되어 사용자 프로그램의 스택과는 별도의 저장공간이 필요하게 되기 때문

            - 자기 자신의 코드 내에서 함수호출 및 복귀 주소를 유지하기 위함

            ➡ 커널은 일종의 공유 코드로서 모든 사용자 프로그램이 시스템 콜을 통해 커널의 함수를 접근할 수 있으므로, 일관성을 유지하기 위해 

            - 시스템 콜 or 인터럽트 등으로 운영체제의 코드가 실행되는 중에 함수호출이 발생할 경우

            유의할 점

            프로그램 내의 함수호출 시 해당 프로그램의 스택에 복귀 주소를 저장하지만, 시스템 콜이나 인터럽트 발생으로 CPU의 수행 주체가 운영체제로 바뀌는 순간에는 직전에 수행되던 프로그램의 복귀 정보를 스택이 아닌 PCB에 저장된다는 점 

            ![3](Untitled%203.png)

## 4.  사용자 프로그램이 사용하는 함수

- 프로그램이 사용하는 함수는 크게 사용자 정의함수와 라이브러리 함수, 커널함수로 구분
- 1) 사용자 정의함수
- : 프로그래머 본인이 직접 작성한 함수
- 2) 라이브러리 함수
- : 이미 누군가 작성해놓은 함수를 호출만 하여 사용하는 경우

➡ 두 함수 모두 프로그램의 코드 영역에 기계어 명령 형태로 존재 

따라서 프로그램이 실행 될 때에 해당 프로세스의 주소 공간에 포함되며, 함수호출 시에도 자신의 주소 공간에 있는 스택을 사용하게 된다. 

- 3) 커널함수
- : 운영체제 커널의 코드에 정의된 함수
    - 시스템 콜 함수 : 사용자 프로그램이 운영체제의 서비스를 요청하기 위해 호출하는 함수
    - 인터럽트 처리 함수 : 각종 하드웨어 및 소프트웨어가 CPU의 서비스를 요청하기 위해 발생시키는 인터럽트 처리 함수

➡ 운영체제 커널의 주소 공간에 코드가 정의된다. 즉, 운영체제 내에 있는 함수를 사용자 프로그램이 호출해서 사용하는 것 

## 5.  인터럽트

- CPU는 매번 프로그램 카운터가 가리키는 곳에 있는 명령을 수행하는 일밖에 하지 않기 때문에, 현재 수행 중인 프로세스로부터 CPU를 회수해 CPU가 다른 일을 수행하도록 하기 위해서는 **인터럽트 메커니즘**이 필요하다
- 1) CPU는 매번 PC가 가리키는 명령을 하나씩 수행한다.
- 2) 다음 명령을 수행하기 전에 인터럽트 라인이 세팅되어있는지 체크한다.
- 3) 인터럽트가 발생했으면 CPU는 현재 수행하던 프로세스를 멈추고 운영체제의 인터럽트 처리루틴으로 이동해서 인터럽트 처리를 수행한다.
- 4) 인터럽트가 발생하기 직전의 프로세스에게 CPU의 제어권이 다시 넘어가게 된다.

Q. 인터럽트 처리 중에 또 다른 인터럽트가 발생하는 경우에는 ?

A. 원칙적으로는 인터럽트 처리 중에는 다른 인터럽트 발생하는 것을 허용하지 않음 = 일관성 유지

BUT, 더 시급하거나 CPU를 당장 사용해야하는 일이 발생할 수 있다.(중요도가 다름)

- 이와 같은 경우에는 더 높은 우선순위의 인터럽트가 발생한다면 현재 처리 중이던 인터럽트 코드의 수행 지점을 저장하고 우선순위가 높은 인터럽트를 처리하게 된다.
- 끝나면 저장된 주소로 복귀해 이전에 수행하던 인터럽트 처리 코드를 마저 수행하게 된다.

![4](Untitled%204.png)

## 6.  시스템 콜

- 주소 공간 자체가 다른 곳으로 이동함 ➡ 프로그램 자신이 인터럽트 라인에 인터럽트를 세팅하는 명령을 통해 이루어짐

![5](Untitled%205.png)

 ex) 디스크의 파일 입출력이 이루어지는 과정을 통해 시스템 콜 사용의 예

- 사용자 프로그램이 CPU에서 명령을 수행하던 중 디스크의 파일을 읽어와야 할 경우 시스템 콜로 커널의 함수를 호출하게 된다.
- 이때 사용자 프로그램은 CPU의 제어권을 운영체제에게 이양하게 되는데, 이는 인터럽트 라인을 세팅하는 명령을 통해 이루어진다.
- 인터럽트 라인이 세팅되면 CPU는 다음 명령을 수행하기 전에 인터럽트가 발생했는지 점검하게 되며,
- 이  과정에서 인터럽트가 발생한 것을 인지하고 CPU의 제어권을 운영체제로 이양시키게 된다.
- 인터럽트 라인에 의해 입출력 요청하는 인터럽트임을 인지
- 해당 서비스루틴으로 이동해 입출력 작업을 수행하게 된다.
- ➡  CPU는 디스크 컨트롤러에게 파일을 읽어오라는 명령

디스크에서 데이터를 읽어오는 일은 많은 시간이 소요된다. 

따라서, 입출력을 요청한 다음 CPU의 제어권을 다른 프로세스에게 이양한다. 

- 다른 프로세스가 CPU에서 명령령을 수행하던 중 입출력 작업이 완료되면 디스크 컨트롤러가 CPU에게 인터럽트를 발생시켜 요청된 작업이 완료되었음을 알린다.
- CPU는 사용자 프로세스의 수행을 멈추고 인터럽트 처리루틴으로 그 제어권이 넘어간다.
- 처리 내용은 디스크로부터 로컬버퍼로 읽어온 내용을 컴퓨터 내의 메모리로 복사한 후 요청한 프로세스에게 다시 CPU를 획득할 수 있는 권한을 주는 것
- 해당 프로세스틑 CPU를 기다리는 큐에 삽입되고 CPU의 제어권은 다시 인터럽트를 당한 프로세스로 넘어가 하던 작업을 계속 수행하게 된다.
- 

 프로그램이 중간에 CPU를 빼앗기는 경우 크게 2가지

- 타이머에 의해 인터럽트가 발생하는 경우
    - : CPU 할당시간이 만료되면 인터럽트를 발생시킴
    - 특정 프로그램에 의해 CPU가 독점되는 것을 방지하기 위한 하드웨어
- 입출력 요청을 위해 시스템 콜을 하는 경우
    - 입출력 요청이 완료된 후 컨트롤러가 인터럽트를 발생시킨 시점부터 다시 CPU를 얻을 수 있는 자격을 부여받게 된다.

## 7.  프로세스의 두 가지 실행 상태

하나의 프로세스가 시작되어 수행을 완료하기까지

프로세스 자신의 주소 공간에 있는 코드 + 커널의 주소 공간에 있는 코드 실행된다.

- 프로세스가 CPU에서 실행되고 있다는 것은 2가지로 나누어볼 수 있다.
- 자신의 주소 공간에 정의된 코드를 실행하는 것 = 사용자모드에서의 실행상태(user mode running)
- 커널의 시스템 콜 함수를 실행하는 것 = 커널모드에서의 실행상태 (kernel mode running)

주의해야할 점 !

비록 시스템 콜을 통해 실행되는 것이 프로세스 A의 코드가 아닌 운영체제 커널의 코드이지만, 시스템 콜이 수행되는 동안 커널이 실행 상태( running state )에 있다고 하지 않고 프로세스 A가 실행상태에 있다고 말한다는 점이다.  

![6](Untitled%206.png)